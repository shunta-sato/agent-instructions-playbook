# Quality gate checklist

Before you submit, confirm all items below.

- Checks are **all green** (build / format / static analysis / tests). Write the exact commands and key results.
- Path-specific instructions (when applicable):
  - Identify matching `.github/instructions/*.instructions.md` by `applyTo`.
  - Confirm they were followed (or state why none applied).
- Observability (when runtime behavior changes):
  - logs: start/outcome/failure present with identifiers
  - metrics: errors + latency (golden signals if relevant)
  - traces: spans/correlation IDs connect logs and metrics
  - safety: no secrets/PII; logging guidance followed
- UI verification gate (when UI changed):
  - UI Visual Verification Report exists and uses the required format
  - snapshots were verified, or baselines were updated intentionally with rationale
  - artifact paths are listed (diff images/reports/snapshot folders)
- C++ documentation (when C++ was touched):
  - `.hpp`: Doxygen for all declarations (including private)
  - `.cpp`: paragraph intent comments; boundary/coupling-point contract notes
  - constants: meaning/unit/range (or rationale)
  - unit tests: make why/what readable
- Bugfix evidence + report (required when bugfix mode was triggered):
  - Bug Report exists (PR description, issue comment, or docs file)
  - Report includes repro (or why reproduction is currently impossible), evidence, Five Whys root cause, verification, and at least one prevention action with measurable end state
  - Workaround-only changes are blocked unless risk, removal plan, and follow-up task are documented
- Requirements documentation (when requirements/acceptance changed):
  - updated requirements/acceptance are unambiguous and measurable
  - verification method and trace (design/tests) exists
  - if unsure, invoke `$requirements-documentation`
- Smells / anti-patterns (when structural change):
  - `$code-smells-and-antipatterns` was run
  - It reports **0 new/worsened** findings (or all such findings were fixed)
  - Any “not fixed” items are explicitly marked as “not introduced/worsened” and include a follow-up note
- Readability:
  - identify up to 3 reader-stoppers and fix with minimal diffs (with cited headings from `code-readability`)
- Modularity:
  - list changed units; rate cohesion/coupling by the worst level; fix or justify
- Boundaries:
  - core code does not depend on outer types; DIP/DTO used where needed
- Error handling:
  - translate errors at boundaries; no swallowed failures
- Requirements ↔ tests:
  - every requirement / acceptance criterion has a passing test (or a reproducible procedure)
- Test List:
  - if unfinished items remain, write the reason, risk, and the next item to do
